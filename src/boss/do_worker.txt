// Pushed code
// TODO: refactor into worker.go style

package main

import (
	"os"
	"fmt"
	"time"
	"context"
	"strconv"

	"github.com/digitalocean/godo"
)

// Global variables
const BOSS_IDX int = 0 // ASSUME: Boss is the first VM created
const SNAPSHOT_NAME string = "boss snap"
const CHILD_NAME string = "tony"
var SNAPSHOT_DROP time.Duration
var CREATE_DROP time.Duration

// Click Snapshot function
func click_snap(client *godo.Client, droplet_id int, snap_name string) ([]godo.Snapshot, error) {
	
	// Etablishing auth info
	ctx := context.TODO()

	// Make POST: click Snapshot
	/////////////////////// START
	t0 := time.Now()
	action, _, err := client.DropletActions.Snapshot(ctx, droplet_id, snap_name)
	snap_act_id := action.ID
	status := action.Status
	fmt.Println("Clicked Snapshot. Waiting for request to complete...")
	
	// Polling 
	for status != "completed" {
		
		// Sleep
		time.Sleep(1 * time.Second)

		// Make GET: Snapshot information
		action, _, err := client.DropletActions.Get(ctx, droplet_id, snap_act_id)
		if err != nil {
			return nil, err
		}
		status = action.Status // Keep looping
	}
	SNAPSHOT_DROP = time.Since(t0)
	/////////////////////// STOP
	fmt.Println("Wait complete. Returning...")

	// Make GET: Snapshot Info
	opt := &godo.ListOptions{
		Page:    1,
		PerPage: 200,
	}
	snapshots, _, err:=client.Snapshots.List(ctx, opt)

	// Return most recent snapshot slice
	return snapshots, err
}

func main() {
	// TODO: Remove cmdline logic -- ONLY FOR DEBUGGING
	// Pass 'true' to DESTROY droplet created
	// Pass 'false' to PRESERVE droplet created
	to_destroy, _ := strconv.ParseBool(os.Args[1:][0])
	
	// Establishing auth information
	token := os.Getenv("DIGITALOCEAN_TOKEN")
	client := godo.NewFromToken(token)
	ctx := context.TODO()

	// REST call body
	opt := &godo.ListOptions{
		Page:    1,
		PerPage: 200,
	}

	// Make GET: Droplet Info
	droplets, _, err := client.Droplets.List(ctx, opt)
	if err != nil {
		fmt.Println("ERROR: An error was encountered while listing droplets. Aborting...\nError Message:", err)
		return
	}

	// Make GET: SSH information
	keys, _, err := client.Keys.List(ctx, opt)
	if err != nil {
		fmt.Println("ERROR: An error was encountered while listing SSH information. Aborting...\nError Message:", err)
		return
	}

	// Assign boss credentials
	boss_drop := droplets[BOSS_IDX]
	boss_ssh := keys[BOSS_IDX]

	// Make GET: Snapshot Info
	snapshots, _, err:=client.Snapshots.List(ctx, opt)
	if err != nil {
		fmt.Println("ERROR: An error was encountered while listing Snapshot information. Aborting...\nError Message:", err)
		return
	}
	if len(snapshots) == 0 {
		// If snapshot DNE, click new snapshot: ETA 6.5 min
		fmt.Println("No snapshots found! Click new snapshot of boss")
		snapshots, err = click_snap(client, boss_drop.ID, SNAPSHOT_NAME)
		if err != nil {
			fmt.Println("ERROR: An error was encountered while clicking a snapshot. Aborting...\nError Message:", err)
			return
		}
		fmt.Printf("New snapshot '%v' successfully clicked.\n", SNAPSHOT_NAME)
	} // Otherwise, use existing snapshot
	
	// Assign snapshot credentials
	boss_snap := snapshots[BOSS_IDX]
	boss_snap_id, _ := strconv.Atoi(boss_snap.ID)
	boss_snap_region := boss_snap.Regions[BOSS_IDX] // ASSUME: child droplet region is boss's first region 
	
	// Make POST: create Droplet
	// Request body
	create_request := &godo.DropletCreateRequest{
		Name:   CHILD_NAME,
		Region: boss_snap_region,
		Size:   boss_drop.Size.Slug,
		Image: godo.DropletCreateImage{
			ID: boss_snap_id,
		},
		SSHKeys: []godo.DropletCreateSSHKey{
			{ID: boss_ssh.ID},
			{Fingerprint: boss_ssh.Fingerprint},
		},
	}
	/////////////////////// START
	t0 := time.Now()
	child_drop, _, err:=client.Droplets.Create(ctx, create_request)
	if err != nil {
		fmt.Println("ERROR: An error was encountered while creating new Droplet. Aborting...\nError Message:", err)
		return
	}
	fmt.Printf("Created Droplet %v. Waiting for request to complete...\n", child_drop.Name)
	status := child_drop.Status // status: 'new' after creation
	
	// Polling
	for status != "active" {

		// Sleep
		time.Sleep(1 * time.Second)

		// Make GET: Droplet information
		child_drop, _, err := client.Droplets.Get(ctx, child_drop.ID)
		if err != nil {
			fmt.Println("ERROR: An error was encountered while retrieving Droplet information. Aborting...\nError Message:", err)
			return
		}
		status = child_drop.Status // Keep looping
	}
	CREATE_DROP = time.Since(t0)
	/////////////////////// END

	fmt.Printf("Wait complete. %v was created successfully\n", child_drop.Name)

	/////////////////////////////////////
	// TODO: Fill out worker.go struct //
	/////////////////////////////////////

	if to_destroy == false {
		fmt.Printf("Droplet (DROPLET ID: %v) was preserved.\n", child_drop.ID)
	} else {
		// Make POST: destroy Droplet -- based on input flag
		_, err := client.Droplets.Delete(ctx, child_drop.ID)
		if err != nil {
			fmt.Printf("ERROR: An error was encountered while destroying %v Droplet. Aborting...\nError Message: %v\n", child_drop.Name, err)
			return
		}

		fmt.Printf("Droplet %v (DROPLET ID: %v) was DESTROYED.\n", child_drop.Name, child_drop.ID)
	}
	
	// Sanity check
	fmt.Printf("Client type: %T\nBoss droplet ID: %v\nBoss droplet SSH: %v\t%v\nSnapshot: %v\n", client, boss_drop.ID, boss_ssh.ID, boss_ssh.Fingerprint, boss_snap)

	// Perf Measurement
	fmt.Printf("SNAPSHOT_DROP: %v\nCREATE_DROP: %v\n", SNAPSHOT_DROP, CREATE_DROP)
}


